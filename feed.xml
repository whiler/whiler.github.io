<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>轨迹</title><link href="https://whiler.github.io/" rel="alternate"></link><link href="https://whiler.github.io/feed.xml" rel="self"></link><id>https://whiler.github.io/</id><updated>2023-03-08T00:00:00+08:00</updated><entry><title>NoScreen 简介</title><link href="https://whiler.github.io/noscreen.html" rel="alternate"></link><published>2023-03-07T00:00:00+08:00</published><updated>2023-03-07T00:00:00+08:00</updated><author><name></name></author><id>tag:whiler.github.io,2023-03-07:/noscreen.html</id><summary type="html">&lt;p&gt;NoScreen 一个打开浏览器就能控制远程电脑的远程桌面应用。&lt;/p&gt;</summary><content type="html">&lt;p&gt;先上成品 &lt;a href="https://noscr.v6.navy"&gt;https://noscr.v6.navy&lt;/a&gt; 。&lt;/p&gt;
&lt;h2&gt;咋来的？&lt;/h2&gt;
&lt;p&gt;替表姐远程维护电脑的时候，被各种远程桌面应用折腾得不行不行的，索性自己搓一个。这就有了 &lt;strong&gt;NoScreen&lt;/strong&gt; ，一个打开浏览器就能控制远程电脑的应用。&lt;/p&gt;
&lt;h2&gt;啥是远程桌面应用？&lt;/h2&gt;
&lt;p&gt;所谓的远程桌面应用，就是字面意思： &lt;span class="arithmatex"&gt;&lt;span class="MathJax_Preview"&gt;远程桌面 = 控制 + 远程 + 电脑桌面&lt;/span&gt;&lt;script type="math/tex"&gt;远程桌面 = 控制 + 远程 + 电脑桌面&lt;/script&gt;&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;按下开关，灯就亮了，这是控制；按下遥控器的「静音」按钮，电视机就没声了，是遥控，是远程控制；点击自己的鼠标，远方电脑屏幕上的窗口就关闭了，这是远程控制电脑。&lt;/p&gt;
&lt;p&gt;被控制的东西从灯、电视机到电脑，控制器从开关、遥控器到鼠标和键盘，控制距离从一间屋子到一个城市，这一切都没有本质的区别，都是操作控制器传递命令，让被控物体执行命并给出反馈。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sequence"&gt;人-&amp;gt;遥控器: 按下静音按钮
遥控器-&amp;gt;电视机: 静音
电视机--&amp;gt;人: 没声了
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;怎么搓？&lt;/h2&gt;
&lt;p&gt;远程桌面的控制器是鼠标和键盘，命令是键盘按键、鼠标位置和鼠标点击，反馈显示在远程电脑屏幕上，可以通过截图把反馈传回去。&lt;/p&gt;
&lt;p&gt;搞一个程序，监听键盘按键、鼠标移动和点击事件，这种基本操作就搞定了控制器。把监听到的命令编码后通过网络传递到另一台电脑的程序，调用多种自动化控制软件执行这些命令，这就搞定了执行命令。致于反馈，搞一个程序定时截图，通过网络把截图传给另一个程序并显示，就搞定了。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sequence"&gt;participant 人
participant 控制器
participant 执行程序
participant 屏幕

Note over 控制器,执行程序: 网络

人-&amp;gt;控制器: 按下空格键
控制器-&amp;gt;执行程序: 按下空格键
执行程序 --&amp;gt; 执行程序: 截图
执行程序-&amp;gt;控制器: 显示截图
控制器--&amp;gt;人: 按下空格键成功了
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;「控制」和「执行」实现起来都没什么大问题，「反馈」实现起来问题很大，主要有：家庭宽带的上传很低，图像传输需要占用大量带宽；截图接口耗时较高，每秒截图 20 次都难。&lt;/p&gt;
&lt;p&gt;把一张截图看作视频的一帧，那么把连续多张截图编码成视频就可以节省大量带宽。&lt;/p&gt;
&lt;p&gt;按照「被控程序」把截图编码成视频，「控制程序」远程实时播放视频这个思路，我在流媒体传输和播放上走了不少弯路…… RTMP、RTSP、HLS 和 ffmpeg 几乎让我放弃把截图编码成视频这条路。&lt;/p&gt;
&lt;p&gt;偶然看到 WebRTC 的 getDisplayMedia 接口，它简直就是为远程桌面量身定制的！不用操心视频编码和传输了，也不用担心截图耗时，一步到位。WebRTC 的 RTCPeerConnection 还解决了网络连接的问题，直连或者中转都能搞定。还不用考虑多操作系统多架构兼容的问题，浏览器都搞定了，真香！就它了。&lt;/p&gt;
&lt;p&gt;选定 WebRTC 后，就需要重新实现控制器和执行程序了。在网页中捕获键盘按键、鼠标移动和点击非常方便，控制器的原型很快就搞定了。被控端的执行程序有两种实现方式：要么作为客户端从服务器上拉取命令，然后执行；要么作为服务端，等控制端把命令推过来，再执行。单独为传递命令搞一个服务太麻烦，延长了数据链，还提高了安全风险，不行只能做服务端。控制端通过 RTCPeerConnection 直接把命令传给被控端，被控端将命令转发给本地执行程序，没有第三方服务的介入，靠谱，我看行。做服务端也带来了一个问题：因为只能在 HTTPS 环境下才能调用 getDisplayMedia 接口，执行程序必须提供 HTTPS 环境。搞一个服务器，定期更新 HTTPS 证书，把执行程序和证书一起打包，提供下载链接，证书过期了就重新下载。而且 WebRTC 本来就需要一个服务器托管网页和信令服务，可以把更新证书和打包的活也交给它。&lt;/p&gt;
&lt;p&gt;就这么愉快地把所有的问题都搞定了，所有涉及到的程序和服务都开源了 &lt;a href="https://github.com/whiler/noscreen"&gt;https://github.com/whiler/noscreen&lt;/a&gt; 。&lt;/p&gt;
&lt;h2&gt;怎么用？&lt;/h2&gt;
&lt;p&gt;如果是使用远程桌面这个功能。&lt;/p&gt;
&lt;p&gt;被控端打开 &lt;a href="https://noscr.v6.navy/"&gt;https://noscr.v6.navy/&lt;/a&gt; ，选择对应的被控端程序包下载，解压并执行，然后点击页面上的「共享」按钮，最后告诉控制端你的编号就可以了。&lt;/p&gt;
&lt;p&gt;控制端打开 &lt;a href="https://noscr.v6.navy/"&gt;https://noscr.v6.navy/&lt;/a&gt; ，输入被控端的编号，点击「控制」即可。&lt;/p&gt;
&lt;p&gt;&lt;img alt="效果图" src="https://search.pstatic.net/common?src=https://i.imgur.com/tlR6bX2.png" title="效果图"&gt;&lt;/p&gt;
&lt;p&gt;如果你想自己部署这样的远程控制系统，可以参考 &lt;a href="https://github.com/whiler/noscreen/blob/master/deploy.md"&gt;deploy.md&lt;/a&gt; ，里面有为 Ubuntu 和 Debian 实现的一键部署脚本。&lt;/p&gt;</content><category term="misc"></category></entry><entry><title>把一张纸撕成一个纸圈</title><link href="https://whiler.github.io/paper-circle.html" rel="alternate"></link><published>2018-05-21T00:00:00+08:00</published><updated>2018-05-21T00:00:00+08:00</updated><author><name></name></author><id>tag:whiler.github.io,2018-05-21:/paper-circle.html</id><summary type="html">&lt;p&gt;不用任何粘接工具，把一张纸撕成一个纸圈&lt;/p&gt;</summary><content type="html">&lt;p&gt;一次培训的放松环节，导师让我们在 5 分钟内，把一张纸撕成一个纸圈，围住我们所有人。&lt;/p&gt;
&lt;p&gt;我做到了。&lt;/p&gt;
&lt;p&gt;一张纸从中间开始撕，能撕成一个闭合的圈。如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="纸圈" src="https://whiler.github.io/assets/images/circle.jpg" title="一张纸从中间开始撕，能撕成一个闭合的圈"&gt;&lt;/p&gt;
&lt;p&gt;从边上撕能得到纸条，而不是闭合的圈。如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="纸条" src="https://whiler.github.io/assets/images/strip.jpg" title="从边上撕能得到纸条，而不是闭合的圈"&gt;&lt;/p&gt;
&lt;p&gt;从中间撕能得到一个圈，周长最大也只能是纸的周长，不能围住所有人。
从边上撕能得到一个纸条，只要撕得足够细，纸条可以就可以足够的长，首尾相连形成圈就能围住所有人了。
但是，怎么连呢？&lt;/p&gt;
&lt;p&gt;对折！&lt;/p&gt;
&lt;p&gt;对折后从中间撕一个口子，展开就是一个圈了。如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="对折" src="https://whiler.github.io/assets/images/fold-1.jpg" title="对折"&gt;
&lt;img alt="撕一个口子" src="https://whiler.github.io/assets/images/fold-2.jpg" title="撕一个口子"&gt;
&lt;img alt="圈" src="https://whiler.github.io/assets/images/fold-3.jpg" title="得到一个圈"&gt;&lt;/p&gt;
&lt;p&gt;能不能把这个圈的周长变得更大一些呢？&lt;/p&gt;
&lt;p&gt;能，对折后从折线一边开始，左右交替撕奇数个口子；把折线上除第一个和最后一个折痕撕开，展开就能得到周长更长的圈了。如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="左右交替撕奇数个口子" src="https://whiler.github.io/assets/images/tear.jpg" title="左右交替撕奇数个口子，把折线上除第一个和最后一个折痕撕开"&gt;
&lt;img alt="展开" src="https://whiler.github.io/assets/images/unfold.jpg" title="展开，得到一个圈"&gt;&lt;/p&gt;
&lt;p&gt;假设纸的周长是 d ，圈的周长是 D ，对折一次，左右交替撕奇数 &lt;span class="arithmatex"&gt;&lt;span class="MathJax_Preview"&gt;N = 2 * n - 1&lt;/span&gt;&lt;script type="math/tex"&gt;N = 2 * n - 1&lt;/script&gt;&lt;/span&gt; 个口子，那么纸圈的周长可以表示为：&lt;/p&gt;
&lt;div class="arithmatex"&gt;
&lt;div class="MathJax_Preview"&gt;D = (N + 1) / 2 *d&lt;/div&gt;
&lt;script type="math/tex; mode=display"&gt;D = (N + 1) / 2 *d&lt;/script&gt;
&lt;/div&gt;</content><category term="misc"></category></entry><entry><title>写了一个简单的拼图游戏</title><link href="https://whiler.github.io/puzzle.html" rel="alternate"></link><published>2018-04-14T00:00:00+08:00</published><updated>2018-05-05T00:00:00+08:00</updated><author><name></name></author><id>tag:whiler.github.io,2018-04-14:/puzzle.html</id><summary type="html">&lt;p&gt;用 HTML/JavaScript/CSS 写了一个简单的拼图游戏。&lt;/p&gt;</summary><content type="html">&lt;p&gt;游戏地址： &lt;a href="./html/puzzle/"&gt;拼图/Puzzle&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;早就想写一个拼图游戏了，以前被 &lt;code&gt;生成的拼图没法还原&lt;/code&gt; 的问题唬住了，迟迟没能动手写。
今天抽了几个小时做了一个简单的拼图游戏。&lt;/p&gt;
&lt;p&gt;随机生成的拼图不一定能还原，但是可以通过 &lt;strong&gt;从还原好的拼图随机打乱&lt;/strong&gt; 的方式生成拼图。
这样，生成的拼图 100% 能还原，解决了 &lt;code&gt;生成的拼图没法还原&lt;/code&gt; 的问题。&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;从还原好的拼图随机打乱&lt;/strong&gt; 时遇到一个棘手的问题，白块总是「原地踏步」——白块平均概率向四个方向移动，走了一圈又回到了原位。
找到一个不是很完美的解决办法，通过白块当前的位置动态计算向四个方向移动的概率，然后按照四个方向不同的概率移动，终于走出起始点了。
但是，当白块移动到正中央的时候四个方向的概率又相同了，又有「原地踏步」的可能。
目前没有想到其他更好的办法。&lt;/p&gt;
&lt;p&gt;没有 &lt;strong&gt;自动还原&lt;/strong&gt; 功能时，总想着把这个功能加上，费劲实现这个功能后就不再想亲自好好玩一把拼图了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自动还原&lt;/strong&gt; 功能其实并不难，前期调研时候就知道可以用 &lt;em&gt;A 星&lt;/em&gt; 算法实现，难在学习和实现这个算法上了，还有 &lt;em&gt;A 星&lt;/em&gt; 依赖的 &lt;em&gt;二叉堆&lt;/em&gt; 。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-dot"&gt;digraph AStar {
    bgcolor=&amp;quot;transparent&amp;quot;;

    S -&amp;gt; A[label=10]
    S -&amp;gt; B[label=10]
    S -&amp;gt; C[label=10]
    S -&amp;gt; D[label=10]
    A -&amp;gt; E[label=10,style=dashed]
    B -&amp;gt; E[label=20,style=dashed]
    C -&amp;gt; E[label=30,style=dashed]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;A 星&lt;/em&gt; 算法是一个启发性寻路算法，是最有效的直接搜索算法。其他的寻路算法还有广度优先、深度优先和 DijKstra 算法。
算法不断从开放区域选取代价最小的节点，通过该节点再生成该节点的子节点并放到开放区域中，直到找到目标节点。
算法的关键在 &lt;strong&gt;选取代价最小的节点&lt;/strong&gt; ，这个操作需要预估该节点到目标节点的代价。
&lt;a href="https://gist.github.com/whiler/259285dca698f7b59970c3d34584111c"&gt;A 星算法实现&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-dot"&gt;digraph BinaryHeap {
    bgcolor=&amp;quot;transparent&amp;quot;;

    7 -&amp;gt; 17
    7 -&amp;gt; 13
    17 -&amp;gt; 23
    17 -&amp;gt; 19
    13 -&amp;gt; 29
    List[shape=record,label=&amp;quot;{&amp;lt;f0&amp;gt;7|&amp;lt;f1&amp;gt;17|&amp;lt;f2&amp;gt;13|&amp;lt;f3&amp;gt;23|&amp;lt;f4&amp;gt;19|&amp;lt;f5&amp;gt;29}&amp;quot;]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;A 星&lt;/em&gt; 算法每次都需要选取代价最小的节点，这样的操作十分适合用 &lt;em&gt;二叉堆&lt;/em&gt; 来实现。
&lt;em&gt;二叉堆&lt;/em&gt; 是一种队列，不同于常见的先进先出、先进后出队列，它随意进队，最小的出队。进队出队的时间复杂队都是 &lt;span class="arithmatex"&gt;&lt;span class="MathJax_Preview"&gt;O(log(n))&lt;/span&gt;&lt;script type="math/tex"&gt;O(log(n))&lt;/script&gt;&lt;/span&gt; 。
它用线性的数组／列表抽象地构造出一个完全二叉树，树上每一个节点小于它的子节点。
&lt;a href="https://gist.github.com/whiler/67668f14c0466eca081a203d5655f779"&gt;二叉堆实现&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;变更历史&lt;/h3&gt;
&lt;h4&gt;2018-05-05&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;增加评分功能&lt;/li&gt;
&lt;li&gt;根据浏览器自动适配中文版和英文版&lt;/li&gt;
&lt;li&gt;美化样式&lt;/li&gt;
&lt;li&gt;难度调整&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;2018-04-24&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;完善用户体验&lt;ul&gt;
&lt;li&gt;新增「开始」交互界面&lt;/li&gt;
&lt;li&gt;新增 「游戏中」交互界面&lt;/li&gt;
&lt;li&gt;新增 「游戏结束」交互界面&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;新增 &lt;strong&gt;「自动还原」&lt;/strong&gt; 功能&lt;/li&gt;
&lt;li&gt;可以随意选取开始位置&lt;/li&gt;
&lt;li&gt;新增「猫」「狗」背景图，随机选择概率分别是 50% 和 30%&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;2018-04-14&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;增加还原判定&lt;/li&gt;
&lt;li&gt;适配竖屏&lt;/li&gt;
&lt;li&gt;参数支持&lt;ul&gt;
&lt;li&gt;网格设置&lt;/li&gt;
&lt;li&gt;难度设置&lt;/li&gt;
&lt;li&gt;背景图更换&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content><category term="misc"></category></entry><entry><title>用虚拟私用网络访问敏感网络</title><link href="https://whiler.github.io/bypass-via-vpn.html" rel="alternate"></link><published>2016-10-18T00:00:00+08:00</published><updated>2016-10-18T00:00:00+08:00</updated><author><name></name></author><id>tag:whiler.github.io,2016-10-18:/bypass-via-vpn.html</id><summary type="html">&lt;p&gt;利用 域名列表 、dnsmasq 、 iptables 和 ipset 配合 虚拟私用网络 精确到域名解决网络封锁。&lt;/p&gt;</summary><content type="html">&lt;p&gt;相对于 &lt;a href="https://whiler.github.io/bypass.html"&gt;绕开网络封锁访问敏感域名&lt;/a&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;依赖 虚拟私用网络 ；&lt;/li&gt;
&lt;li&gt;不再依赖 pdnsd ；&lt;/li&gt;
&lt;li&gt;通过协议不再仅限于 TCP 和 UDP ；&lt;/li&gt;
&lt;li&gt;客户端本机也可以访问敏感网络。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;利用 域名列表 配合 dnsmasq 和 ipset 收集需要通过 虚拟私用网络 的流量，利用 iptables 和 ipset 识别并标记流量，配置 路由表 让被标记的流量通过 虚拟私用网络 访问。&lt;/p&gt;
&lt;p&gt;大致的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装并配置 虚拟私用网络 服务端；&lt;/li&gt;
&lt;li&gt;安装 虚拟私用网络 客户端；&lt;/li&gt;
&lt;li&gt;创建 ipset ；&lt;/li&gt;
&lt;li&gt;将可信的 DNS 服务器地址添加到 ipset ；&lt;/li&gt;
&lt;li&gt;安装并配置 dnsmasq ；&lt;/li&gt;
&lt;li&gt;创建路由表；&lt;/li&gt;
&lt;li&gt;调整内核 rp filter ；&lt;/li&gt;
&lt;li&gt;自定义 vpnc script 。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;安装并配置 虚拟私用网络 服务端&lt;/h3&gt;
&lt;p&gt;感激 schemacs 赠送的 AnyConnect 虚拟私用网络，让我免去了安装和配置的繁琐。&lt;/p&gt;
&lt;h3&gt;安装 虚拟私用网络 客户端&lt;/h3&gt;
&lt;p&gt;连接 AnyConnect 可以用 OpenConnect 的客户端。&lt;/p&gt;
&lt;h3&gt;创建 ipset&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;ipset create &amp;quot;${SETNAME}&amp;quot; hash:ip
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;将可信的 DNS 服务器地址添加到 ipset&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;ipset add &amp;quot;${SETNAME}&amp;quot; 8.8.8.8
ipset add &amp;quot;${SETNAME}&amp;quot; 8.8.4.4
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;安装并配置 dnsmasq&lt;/h3&gt;
&lt;p&gt;修改 /etc/dnsmasq.conf 在最后加入 conf-dir=/etc/dnsmasq.d/,*.conf ，新建并进入 /etc/dnsmasq.d 目录；
创建一个后缀为 .conf 的配置文件，为每一个敏感的域名指定可信的 DNS 解析服务器，并将解析得到的地址添加到 ipset 中。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;echo &amp;quot;conf-dir=/etc/dnsmasq.d/,*.conf&amp;quot; &amp;gt;&amp;gt; /etc/dnsmasq.conf

mkdir -p /etc/dnsmasq.d

echo &amp;quot;server=/google.com/8.8.8.8&amp;quot;   &amp;gt;&amp;gt; &amp;quot;/etc/dnsmasq.d/${static}.conf&amp;quot;
echo &amp;quot;ipset=/google.com/${SETNAME}&amp;quot; &amp;gt;&amp;gt; &amp;quot;/etc/dnsmasq.d/${static}.conf&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;创建路由表&lt;/h3&gt;
&lt;p&gt;/etc/iproute2/rt_tables 保存了系统的路由表。
向文件中写入一行即可创建一个路由表。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;echo -e &amp;quot;${TABLEID}\t${TABLENAME}&amp;quot; &amp;gt;&amp;gt; /etc/iproute2/rt_tables
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;调整内核 rp filter&lt;/h3&gt;
&lt;p&gt;由于用到部分 策略路由 ，需要将内核反向过滤策略关闭或者放宽松。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;echo &amp;quot;net.ipv4.conf.default.rp_filter=2&amp;quot; &amp;gt;&amp;gt; /etc/sysctl.conf
echo &amp;quot;net.ipv4.conf.all.rp_filter=2&amp;quot;     &amp;gt;&amp;gt; /etc/sysctl.conf
sysctl -p
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;自定义 vpnc script&lt;/h3&gt;
&lt;p&gt;若使用 OpenConnect 默认的 &lt;a href="http://git.infradead.org/users/dwmw2/vpnc-scripts.git/blob_plain/HEAD:/vpnc-script"&gt;vpnc script&lt;/a&gt; ，它会替换系统默认路由，让所有流量都通过 虚拟私用网络 ，显然这样不合理。&lt;/p&gt;
&lt;p&gt;默认的 vpnc script 主要实现了两个函数 do_connect 和 do_disconnect 。&lt;/p&gt;
&lt;p&gt;do_connect 在开始连接 虚拟私用网络 时，依次调用 set_vpngateway_route 、 do_ifconfig 和 set_default_route 三个函数，其中 set_default_route 将系统默认的路由替换成了 虚拟私用网络 分配的路由。&lt;/p&gt;
&lt;p&gt;do_disconnect 在退出 虚拟私用网络 时，依次调用 reset_default_route 、 del_vpngateway_route 和 destroy_tun_device ，其中 reset_default_route 函数恢复系统原来的路由。&lt;/p&gt;
&lt;p&gt;我们需要实现 start_split_tunneling 和 stop_split_tunneling 来替换 set_vpngateway_route 和 reset_default_route 完成分流。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;start_split_tunneling() {
    # mark
    # 目的地址匹配 ipset 则打上标记
    iptables --table mangle --insert PREROUTING --match set --match-set &amp;quot;${SETNAME}&amp;quot; dst --jump MARK --set-mark &amp;quot;${MARK}&amp;quot;
    iptables --table mangle --insert OUTPUT     --match set --match-set &amp;quot;${SETNAME}&amp;quot; dst --jump MARK --set-mark &amp;quot;${MARK}&amp;quot;

    # forwarding
    # 允许流量进出 TUNDEV
    iptables --table filter --insert FORWARD --out-interface &amp;quot;${TUNDEV}&amp;quot; --jump ACCEPT
    iptables --table filter --insert FORWARD --in-interface  &amp;quot;${TUNDEV}&amp;quot; --jump ACCEPT

    # nat
    # 地址伪装
    iptables --table nat --insert POSTROUTING --out-interface &amp;quot;${TUNDEV}&amp;quot; --jump MASQUERADE

    # rule
    # 所有带标记的流量都通过指定的路由表
    ip rule add fwmark ${MARK} table ${TABLENAME}

    # gateway
    # 为路由表指定默认的路由设备
    ip route add default dev &amp;quot;${TUNDEV}&amp;quot; src &amp;quot;${INTERNAL_IP4_ADDRESS}&amp;quot; table &amp;quot;${TABLENAME}&amp;quot;
}

stop_split_tunneling() {
    # gateway
    ip route del default dev &amp;quot;${TUNDEV}&amp;quot; src &amp;quot;${INTERNAL_IP4_ADDRESS}&amp;quot; table &amp;quot;${TABLENAME}&amp;quot;

    # rule
    ip rule del fwmark ${MARK} table ${TABLENAME}

    # nat
    iptables --table nat --delete POSTROUTING --out-interface &amp;quot;${TUNDEV}&amp;quot; --jump MASQUERADE

    # forwarding
    iptables --table filter --delete FORWARD --out-interface &amp;quot;${TUNDEV}&amp;quot; --jump ACCEPT
    iptables --table filter --delete FORWARD --in-interface  &amp;quot;${TUNDEV}&amp;quot; --jump ACCEPT

    # mark
    iptables --table mangle --delete PREROUTING --match set --match-set &amp;quot;${SETNAME}&amp;quot; dst --jump MARK --set-mark &amp;quot;${MARK}&amp;quot;
    iptables --table mangle --delete OUTPUT     --match set --match-set &amp;quot;${SETNAME}&amp;quot; dst --jump MARK --set-mark &amp;quot;${MARK}&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考： &lt;a href="https://github.com/clowwindy/ShadowVPN/wiki/ShadowVPN----ipset"&gt;ShadowVPN ipset&lt;/a&gt;&lt;/p&gt;</content><category term="misc"></category></entry><entry><title>绘制心形图案</title><link href="https://whiler.github.io/heart.html" rel="alternate"></link><published>2016-04-14T00:00:00+08:00</published><updated>2016-04-14T00:00:00+08:00</updated><author><name></name></author><id>tag:whiler.github.io,2016-04-14:/heart.html</id><summary type="html">&lt;p&gt;半夜没事瞎折腾，想到绘制心形图案消磨时间。&lt;/p&gt;</summary><content type="html">&lt;p&gt;半夜没事瞎折腾，想到绘制心形图案消磨时间。
看了一些方案，最后采用半圆加正方形折叠的方式来绘制，&lt;code&gt;r = a * (1 - sin θ)&lt;/code&gt; 真心不会。&lt;/p&gt;
&lt;p&gt;绘制心形图案，首先想到了笛卡尔的 &lt;code&gt;r = a * (1 - sin θ)&lt;/code&gt; ，但是折腾了半天不会将极坐标系的点转换到笛卡尔坐标系，于是改用正方形外接一个半圆再折叠一次来表示。
这样就只剩下简单的几何代数运算了。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-
#

from math import sin, sqrt, pi


def heart(radius):
    side = radius * sin(pi / 4.0)
    offset = radius + side
    steps = radius + 3.0 * side
    top = 0
    while top &amp;lt;= steps:
        if top &amp;lt; offset:
            delta = sqrt(top * (2.0 * radius - top))
            left_min = side - delta
            if left_min &amp;lt; 0:
                left_min = 0.0
            left_max = side + delta
        else:
            left_max = steps - top
            left_min = 0.0

        line = ''
        i = 0
        while i &amp;lt; offset + left_max:
            if offset - left_max &amp;lt;= i &amp;lt;= offset - left_min:
                line = line + '*'
            elif offset + left_min &amp;lt;= i &amp;lt;= offset + left_max:
                line = line + '*'
            else:
                line = line + ' '
            i = i + 1

        print(line)

        top = top + 1
&lt;/code&gt;&lt;/pre&gt;</content><category term="misc"></category></entry><entry><title>绕开网络封锁访问敏感域名</title><link href="https://whiler.github.io/bypass.html" rel="alternate"></link><published>2016-04-11T00:00:00+08:00</published><updated>2016-04-11T00:00:00+08:00</updated><author><name></name></author><id>tag:whiler.github.io,2016-04-11:/bypass.html</id><summary type="html">&lt;p&gt;用域名列表、dnsmasq 、 pdnsd 、 iptables 和 ipset 配合 shadowsocks-libev 精确到域名解决 tcp 连接封锁、dns 劫持、dns 请求 udp 丢包的问题，绕过网络封锁。&lt;/p&gt;</summary><content type="html">&lt;p&gt;用域名列表、dnsmasq 、 pdnsd 、 iptables 和 ipset 配合 shadowsocks-libev 精确到域名解决 TCP 连接封锁、DNS 劫持、DNS 请求 UDP 丢包的问题，绕过网络封锁。&lt;/p&gt;
&lt;p&gt;首先，用 shadowsocks-libev 建立透明代理，绕开网络封锁；
配置 iptables ，配合 ipset 让匹配 ipset 的 TCP 数据都转发到透明代理；
利用 pdnsd 通过 TCP 向可信的 DNS 服务器转发请求；
用 dnsmasq 配置敏感的域名用 pdnsd 解析，并将解析结果写入 ipset 。&lt;/p&gt;
&lt;p&gt;大致的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装并配置 shadowsocks-libev ；&lt;/li&gt;
&lt;li&gt;创建 ipset ；&lt;/li&gt;
&lt;li&gt;创建 iptables 规则；&lt;/li&gt;
&lt;li&gt;安装并配置 pdnsd ；&lt;/li&gt;
&lt;li&gt;将可信的 DNS 服务器地址添加到 ipset ；&lt;/li&gt;
&lt;li&gt;安装并配置 dnsmasq 。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;安装并配置 shadowsocks-libev&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/shadowsocks/shadowsocks-libev"&gt;shadowsocks/shadowsocks-libev&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;创建 ipset&lt;/h3&gt;
&lt;p&gt;创建一个名为 bypass 的 ipset 。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;ipset create bypass hash:ip
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;创建 iptables 规则&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;在 nat 表中新建一个名为 BYPASS 的链；&lt;/li&gt;
&lt;li&gt;让访问 shadowsocks 服务器的连接采用默认的规则；&lt;/li&gt;
&lt;li&gt;访问私有网络的连接采用默认的规则；&lt;/li&gt;
&lt;li&gt;所有目标地址匹配 ipset 的 TCP 连接都重定向到 1080 端口（本地开启的 shadowsocks 透明代理端口）；&lt;/li&gt;
&lt;li&gt;将 BYPASS 链添加到 PREROUTING 链；&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;iptables --table nat --new BYPASS

iptables --table nat --append BYPASS --destination X.X.X.X --jump RETURN

iptables --table nat --append BYPASS --destination 0.0.0.0/8 --jump RETURN
iptables --table nat --append BYPASS --destination 10.0.0.0/8 --jump RETURN
iptables --table nat --append BYPASS --destination 100.64.0.0/10 --jump RETURN
iptables --table nat --append BYPASS --destination 127.0.0.0/8 --jump RETURN
iptables --table nat --append BYPASS --destination 169.254.0.0/16 --jump RETURN
iptables --table nat --append BYPASS --destination 172.16.0.0/12 --jump RETURN
iptables --table nat --append BYPASS --destination 192.0.0.0/24 --jump RETURN
iptables --table nat --append BYPASS --destination 192.0.2.0/24 --jump RETURN
iptables --table nat --append BYPASS --destination 192.88.99.0/24 --jump RETURN
iptables --table nat --append BYPASS --destination 192.168.0.0/16 --jump RETURN
iptables --table nat --append BYPASS --destination 198.18.0.0/15 --jump RETURN
iptables --table nat --append BYPASS --destination 198.51.100.0/24 --jump RETURN
iptables --table nat --append BYPASS --destination 203.0.113.0/24 --jump RETURN
iptables --table nat --append BYPASS --destination 224.0.0.0/4 --jump RETURN
iptables --table nat --append BYPASS --destination 240.0.0.0/4 --jump RETURN
iptables --table nat --append BYPASS --destination 255.255.255.255/32 --jump RETURN

iptables --table nat --append BYPASS --protocol tcp --match set --match-set bypass dst --jump REDIRECT --to-ports 1080

iptables --table nat --append PREROUTING --protocol tcp --jump BYPASS
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;安装并配置 pdnsd&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;修改 global 中的 query_method 为 tcp_only ，让 pdnsd 只通过 TCP 向上游 DNS 服务器转发请求；&lt;/li&gt;
&lt;li&gt;修改 global 中的 server_port 为其他非 53 端口，如5353（53 端口为 dnsmasq 留着）；&lt;/li&gt;
&lt;li&gt;添加一个可信的支持 TCP 查询的 DNS 上游服务器，如 Google 公共 DNS 服务器。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;global {
    perm_cache = 2048;
    cache_dir = &amp;quot;/var/cache/pdnsd&amp;quot;;
    run_as = &amp;quot;nobody&amp;quot;;
    server_ip = 127.0.0.1;
    server_port = 5353;
    status_ctl = on;
    paranoid = on;
    query_method = tcp_only;
    min_ttl = 15m;
    max_ttl = 1w;
    timeout = 10;
}

server {
    label = &amp;quot;google&amp;quot;;
    ip = 8.8.8.8, 8.8.4.4;
    root_server = on;
    uptest = none;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;将可信的 DNS 服务器地址添加到 ipset&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;ipset add bypass 8.8.8.8
ipset add bypass 8.8.4.4
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;安装并配置 dnsmasq&lt;/h3&gt;
&lt;p&gt;修改 /etc/dnsmasq.conf 在最后加入 conf-dir=/etc/dnsmasq.d/,*.conf ，新建并进入 /etc/dnsmasq.d 目录；
创建一个名为 bypass.conf  文件，为每一个敏感的域名指定可信的 DNS 解析服务器，并将解析得到的地址添加到 ipset 中。内容如下&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;server=/thinkwithgoogle.com/127.0.0.1#5353
ipset=/thinkwithgoogle.com/bypass
server=/withgoogle.com/127.0.0.1#5353
ipset=/withgoogle.com/bypass
server=/google.com/127.0.0.1#5353
ipset=/google.com/bypass
&lt;/code&gt;&lt;/pre&gt;</content><category term="misc"></category></entry><entry><title>关于这个博客</title><link href="https://whiler.github.io/blog.html" rel="alternate"></link><published>2016-03-04T00:00:00+08:00</published><updated>2023-03-08T00:00:00+08:00</updated><author><name></name></author><id>tag:whiler.github.io,2016-03-04:/blog.html</id><summary type="html">&lt;p&gt;闷头写代码到深夜，灵感闪现，迅速解决困扰了很久的问题，想要欢呼一下，发现已经是深夜了，作罢。&lt;/p&gt;</summary><content type="html">&lt;p&gt;闷头写代码到深夜，灵感闪现，迅速解决困扰了很久的问题，想要欢呼一下，发现已经是深夜了，作罢。
还是用一个博客记下来吧，聊以告慰自己。&lt;/p&gt;
&lt;p&gt;使用的平台和库：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.python.org/"&gt;Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://daringfireball.net/projects/markdown/"&gt;MarkDown&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://pages.github.com/"&gt;GitHub Pages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;a href="https://analytics.google.com/"&gt;Google Analytics&lt;/a&gt;&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://disqus.com/"&gt;Disqus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;a href="https://github.com/gitpython-developers/GitPython"&gt;GitPython&lt;/a&gt;&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;a href="http://lxml.de/"&gt;lxml&lt;/a&gt;&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;a href="https://github.com/trentm/python-markdown2"&gt;markdown2&lt;/a&gt;&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;a href="https://github.com/buriy/python-readability"&gt;readability-lxml&lt;/a&gt;&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;a href="http://requirejs.org/"&gt;RequireJS&lt;/a&gt;&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;a href="https://github.com/sindresorhus/github-markdown-css"&gt;github-markdown-css&lt;/a&gt;&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://highlightjs.org/"&gt;highlight.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;a href="https://github.com/chjj/marked"&gt;marked&lt;/a&gt;&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;a href="https://github.com/janl/mustache.js"&gt;mustache.js&lt;/a&gt;&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;a href="http://ionicons.com/"&gt;Ionicons&lt;/a&gt;&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;a href="https://pythonhosted.org/Markdown/"&gt;Python-Markdown&lt;/a&gt;&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jinja.pocoo.org/"&gt;Jinja2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;a href="https://github.com/aleray/mdx_del_ins"&gt;del_ins&lt;/a&gt;&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.crummy.com/software/BeautifulSoup/"&gt;Beautiful Soup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/zacharyvoase/cssmin"&gt;cssmin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/mankyd/htmlmin"&gt;htmlmin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;a href="https://github.com/gisce/markdown-blockdiag"&gt;Markdown blockdiag&lt;/a&gt;&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/facelessuser/pymdown-extensions"&gt;PyMdown Extensions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/rspivak/slimit"&gt;SlimIt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/miracle2k/webassets"&gt;webassets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Python-Markdown/markdown"&gt;Python-Markdown&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/getpelican/pelican"&gt;Pelican&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.mathjax.org/"&gt;MathJax&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;a href="https://github.com/mhchem/MathJax-mhchem"&gt;MathJax/mhchem Extension&lt;/a&gt;&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/adrai/flowchart.js"&gt;flowchart.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/bramp/js-sequence-diagrams"&gt;JS Sequence Diagrams&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.graphviz.org/"&gt;Graphviz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/sofish/typo.css"&gt;typo.css&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="misc"></category></entry><entry><title>关于/about</title><link href="https://whiler.github.io/about.html" rel="alternate"></link><published>2016-02-28T00:00:00+08:00</published><updated>2023-03-06T00:00:00+08:00</updated><author><name></name></author><id>tag:whiler.github.io,2016-02-28:/about.html</id><summary type="html">&lt;p&gt;一只嘴巴，两个鼻孔，四只眼睛，六块腹肌，拥有22对全球唯一的常染色体以及1对xy性染色体。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="me" src="https://whiler.github.io/assets/images/500.png"&gt;&lt;/p&gt;
&lt;p&gt;一只嘴巴，两个鼻孔，四只眼睛，六块腹肌，拥有 22 对全球唯一的常染色体以及 1 对 &lt;em&gt;XY&lt;/em&gt; 性染色体。
喜欢吃饭、睡觉、吹风、乘凉、游泳、跑步、滑雪、羽毛球以及素描。
典型的程序员，无节操、无下限、闷骚。
想要把代码写成一首诗，但目前只能写成一坨翔，很是苦恼。 &lt;/p&gt;
&lt;p&gt;One guy from the earth, with one mouth, two legs, four eyes and six pack abs, it's me, a software engineer, likes eating, sleeping, walking, swimming, running, playing badminton and snowboarding.&lt;/p&gt;
&lt;h3&gt;find me&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;del&gt;&lt;a href="https://www.zhihu.com/people/whiler" title="whiler @ Zhihu"&gt;知乎&lt;/a&gt;&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;a href="https://www.facebook.com/wenwu.lv.5" title="Wenwu Lv @ Facebook"&gt;Facebook&lt;/a&gt;&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="mailto:wenwu500@qq.com" title="mail to me"&gt;Email&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/whiler" title="whiler @ GitHub"&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="misc"></category></entry><entry><title>my gpg public key</title><link href="https://whiler.github.io/gpg.html" rel="alternate"></link><published>2015-08-29T00:00:00+08:00</published><updated>2023-03-06T00:00:00+08:00</updated><author><name></name></author><id>tag:whiler.github.io,2015-08-29:/gpg.html</id><summary type="html">&lt;p&gt;my gpg public key information.&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Key ID&lt;/h3&gt;
&lt;p&gt;BBACB173D5812CE6&lt;/p&gt;
&lt;h3&gt;Fingerprint&lt;/h3&gt;
&lt;p&gt;0EC2 E0E2 A5DE 62A9 4166 1E0F BBAC B173 D581 2CE6&lt;/p&gt;
&lt;h3&gt;Public Key in ASCII&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;-----BEGIN PGP PUBLIC KEY BLOCK-----

mQINBF/uIjUBEADUBInfWXcRVnmV9NDnNSwUiQs2Wjf3inalW50g05Auonv97hMH
HRLKy1e4FK4+prtxi0Cyyi2efRaewcM5/zqpSmMvtb5g2erAVvhzbCGmIe9NHXBO
VaY8EfnyFFNnK35gHb4g1rSzvriIRP3k6N4NyL22FY4NMDRS/9Nl2IwXZ0If8/c9
1zMKRWKHWwGhtBV3RbFadTn0QOZMlZbCeNglMmIDDMLKaC7977NbUVViR5ZVnmtq
YO93J4fj5xoChVeIgbUZ3dW0UIJiURWN3I7XY5s5pktZVJUMKaIqobxervAyY3zw
k/fpK5cq047rPX0CjAwVx0+fwh7zDrPGWl50L0vaUTV+bTxEdc7/S7lYKX3B/yzv
NqVobF0EbgnfjzS1pr4xBSsOU88ObnNf9w2BoeqL2DRwSWANQSWlhCsWJstJSPUk
lh486OYPzGOvgKv/k8ScYMSQXhCC6P2fks3MdaSYNAXJZOVXZWwf3i+OgiRLlJyG
dVQp6MCWRdu2APEAdK+6cfr4flkqJoFDqiejXVFJ02OsINynMC852ppJzYcUgVtg
LO1vZEgDOVBKfHGSqiDD/4DMypQTp82ib8AD7uSQYSnSJLOdQfecXps5fMv/kcnn
KrtZOAe/ru1faKgqm0w9tzDEVG5Y1YyWMukNEtGir35m/pANyFzbnuaQcwARAQAB
tCt3aGlsZXIgKHByZXNvbmFsIHByaXZhY3kpIDx3ZW53dTUwMEBxcS5jb20+iQJU
BBMBCAA+FiEEDsLg4qXeYqlBZh4Pu6yxc9WBLOYFAl/uIjUCGwMFCQ0oaIAFCwkI
BwIGFQoJCAsCBBYCAwECHgECF4AACgkQu6yxc9WBLOYGZQ//cQkHIqaAjrmITMYG
NTvaab7a8H25U8ex3PZi+HfGzb710qZYiNxMTKaaQaeA6fvxfMxvYz3bcMaWRqOd
jhjpCfdCeUZu0Z3rZ/i4v32oBbL6Njwuq4VuO5AXAbGyL0SAU8dR8XJ0xYdCVRW0
M59hAOX/pIev+8yNoLLwJFsIZztOkJgqac2byUEt8rDDRwlVS/olcNJCmzY8DMKA
UmLphiG1auRvAnDXfwRmdMvkTX+6Lx3S6w3SaQN14HhBvTGIiaOOeAGPKrqNB6mq
FTNy6XwjkaPkufTDXzz6bViL3DExt4t6QFer2vfKNm4xUxsB0n8kqJ7nBcyCtqZy
x1n0t9bwiLNVd6cT169EteDDmWzs3uPOroB/JJ2bRXM2G5usA8gPe8FvlyP7KNsa
AJQTNb4jThYuNrrJo82ZIuLdu79dJH7rC0IeeJELcbshIUzYOACmtpTcMPrjmtL9
3/oKc+SqUgcnJ9rIZpt3Bnq4+CnUu3FJnhSb5LKNyCDiAtgXXd9iauh2/vJw/eTh
e7WOP6LO9rYuT9+H5NskvwP8vUIHGN+lQqay7nXGaxdXIrQTuw7fC5RPkL10iXuK
32F/0QQxqaUjh7ktYjtkFUqDMGJuz7EcHzW5iYf8FGWgjHKbv1iS7LWWfOFUN1P5
6/B2ub1vuXuR9WpQBdyVTCPPsdu5Ag0EX+4iNQEQAJ2HoLadTDmCERkuY/6Gxfr2
OppXSGc+tUfHD2ZtwP8ZIzYKJk2U7Wy95HE6h5BhsAy0oio8T72UxO30ivP/KwXr
4CFHfFxegueOP9COo11yAMJiFZKr+jFt2sUSu7Jw7lS7mqNYtb9/eNGXci0zelsO
UZP726UbJlQ9uOYymHORB8RC/s/5exTP1L19KvKdn7rZpMOnKdk4/AdIiNJoCUIY
oAbjrlii9E1eMgQMbBJmi73V3w+NjkfAgEclqZteILCR7zW9u+ky870UZbRmAEfo
aW1At9y5dSX4JvoKZPBPR2VY6Kq3yqo65HYDsatF84D7OpNzpNRNW0vO8l2VZzIK
f4bIF6Sz8bdyvPdHmPxU3wm5CzvlGWnOPVgxBfcLaByEFiZMSzdnB/Zu7znraZa5
/OANczijU6e5Mwtjr4uvXDcm7J0DoAWMyxmGQV25O411ZFZix1HZdvfMen7BTLiA
eCeoE0fqSy04FobLe21C5rET0zBE3gycoHjjRRlwISZ72mSKVCj7zTxcB+nM/nFv
QJvelnRuv8lcQg1XZyzDSwxICkN5Zg2S2acc322cw6mlfySpj6QdaAuMLIve9DMP
2aeQQMSnw0hGBXGdj791RisNTft454jKAn08w5dE3G6OSB+wyWRuIx5Rgfla/PlK
4OuTEBuPj+r03P4YpbjHABEBAAGJAjwEGAEIACYWIQQOwuDipd5iqUFmHg+7rLFz
1YEs5gUCX+4iNQIbDAUJDShogAAKCRC7rLFz1YEs5oBED/kBD4ttPl9qJcE5MTfX
5aeApazOBw6qjbMZgt1EN0rEt6PYk7GL6+gc+Hz/HZgO/2OH/gp/SAjnKa7vuf/a
4aC7MhQrD6ykPj9vDd3kBAqQ5rKbTG2OOP4+8Ed85as0415WUSqAGfktIUgk8ZgF
gwsUkLtiAHcajnzTxW59wqKCesgu3YkcitXnJfonVmMGh96TIb8YPp+hFk9OVL+o
cL/1u+/DtBGnAVJ4VO4HYm51+zKHx2MhLH8zGoC9rmq0tcZiEx+Yzzc/2G0MAs7x
4EUTl3gBQ2eK5QCFHdT6+ep/9GJNhiD7p7xtz6QXX082W4F9guAY9ts+kmGwVz0q
D1F+rSsbQau2JUCTFNaEtqmptGszMAEuNr6tCj0rzsyTTCWV6QDpr3Sf2369llKV
vZ2/bxIjRMf879Sk5spoknd58v5FUioggQKcSzgdpdMc1a0HZelI/ymrQM64APKd
y2KVpJgQqqtj2b0NzEz15bFFJ6QPUiKuiafSEn7MzHTAZNv8ZhpBDKZnf7dRp/y1
L4GjAckJvvImRpjGVNYuQyc4woDXEcog2HeHPp+7AyCRUPd05enC3sLAjEgcCywS
IOH0oAxe3L2WwFn3FAOHQsLRmtVJQORUCA5IUpkktBpe7+/wwokmE/hFpmSVUKnG
DT9pPXUkVHG1gVMe18zbqt6ftQ==
=RY8W
-----END PGP PUBLIC KEY BLOCK-----
&lt;/code&gt;&lt;/pre&gt;</content><category term="misc"></category></entry><entry><title>六度分割理论</title><link href="https://whiler.github.io/theory-of-six-degrees-contacts.html" rel="alternate"></link><published>2014-09-17T00:00:00+08:00</published><updated>2014-09-17T00:00:00+08:00</updated><author><name></name></author><id>tag:whiler.github.io,2014-09-17:/theory-of-six-degrees-contacts.html</id><summary type="html">&lt;p&gt;一次求职笔试，考到了六度分隔理论，判断两个人之间是否存在可能的联系。&lt;/p&gt;</summary><content type="html">&lt;p&gt;一次求职笔试，考到了六度分隔理论，判断两个人之间是否存在可能的联系。
问题是比较简单的，就是检查权重为1的无向图中两个节点在 6 层内是否有相通的路径。&lt;/p&gt;
&lt;h3&gt;解决办法&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;收集每一个人的一度好友&lt;/li&gt;
&lt;li&gt;从一个人开始，遍历他的所有好友，检查是否是另一个人的好友&lt;/li&gt;
&lt;li&gt;递归检查好友的好友，同时排除上一个好友&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;实现&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-
#

import collections
import itertools
import logging
import random
import string

logging.basicConfig(level=logging.NOTSET,
                    format='[%(levelname)s]\t%(asctime)s\t%(message)s',
                    datefmt='%Y-%m-%d %H:%M:%S %Z')

DEPTH = 6


def create_edges(count):
    edges = set()
    for _ in range(count):
        a = random.choice(string.ascii_uppercase)
        b = random.choice(string.ascii_uppercase)
        while a == b or (a, b) in edges or (b, a) in edges:
            a = random.choice(string.ascii_uppercase)
            b = random.choice(string.ascii_uppercase)
        edges.add((a, b))
    return edges


def build_trees(edges):
    trees = collections.defaultdict(set)
    for a, b in edges:
        trees[a].add(b)
    return trees


def find(trees, a, b):
    if not (a in trees and b in trees):
        return -1
    elif a == b:
        return 0
    return walk(trees, a, b, 1) or -1


def walk(trees, a, b, depth, block=None):
    if depth &amp;gt; DEPTH:
        return -1
    children = trees[a]
    if b in children:
        return depth
    else:
        for child in children:
            if child == block:
                continue
            dep = walk(trees, child, b, depth + 1, a)
            if dep is not None:
                return dep


if __name__ == '__main__':
    edges = create_edges(128)
    trees = build_trees(edges)
    for a, b in itertools.combinations(string.ascii_uppercase, 2):
        dep = find(trees, a, b)
        logging.debug('degrees between %s and %s is %d', a, b, dep)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关于六度分隔理论的详细介绍，可以参考 &lt;a href="https://en.wikipedia.org/wiki/Six_degrees_of_separation"&gt;Six degrees of separation&lt;/a&gt; 。&lt;/p&gt;</content><category term="misc"></category></entry><entry><title>多数据源混合输出</title><link href="https://whiler.github.io/mix-sources.html" rel="alternate"></link><published>2012-07-15T00:00:00+08:00</published><updated>2012-07-15T00:00:00+08:00</updated><author><name></name></author><id>tag:whiler.github.io,2012-07-15:/mix-sources.html</id><summary type="html">&lt;p&gt;拥有相同数据格式的数据源按照数量混合分页输出。&lt;/p&gt;</summary><content type="html">&lt;p&gt;拥有相同数据格式的数据源按照数量混合分页输出。
比如在新闻列表中混合输出政治、经济、娱乐、科技新闻；
在用户 Feed 流中混合输出用户订阅的条目和推荐给用户的条目。&lt;/p&gt;
&lt;p&gt;数据源输出有 &lt;strong&gt;开始正常输出&lt;/strong&gt;、&lt;strong&gt;开始变换输出（填补前一个数据源不足分页的量）&lt;/strong&gt;、&lt;strong&gt;变换输出&lt;/strong&gt; 和 &lt;strong&gt;结束输出&lt;/strong&gt; 四个阶段。
每一个数据源开始时，按照指定的数量输出，到最后一个分页不足时，由下一个数据源填补不足的量。
将前面所有的数据源视为一个数据源，简化计算。&lt;/p&gt;
&lt;h3&gt;实现&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-
#


def source(tag, count):
    return ['%s%02d' % (tag, i) for i in range(count)]


def mix(page, *args):
    sources = [
        (source, len(source) / size, size)
        for source, size in args
    ]
    sources.sort(key=lambda (source, total, size): total)

    total = 0
    size = 0
    delta = list()
    for source, _, need in sources:
        count = len(source)

        if total == size == 0:
            sep = count / need
            if page &amp;lt; sep:
                start = page * need
                delta.extend(source[start: start + need])
            elif page == sep:
                start = page * need
                delta.extend(source[start: start + count % need])
        else:
            sep = total / size
            if page &amp;lt; sep:
                start = page * need
                delta.extend(source[start: start + need])
            elif page == sep:
                start = page * need
                delta.extend(source[start: start + need + size - total % size])
            else:
                if page &amp;lt; (total + count) / (size + need):
                    start = page * (size + need) - total
                    delta.extend(source[start: start + need + size])
                else:
                    start = page * (size + need) - total
                    delta.extend(source[start: start + (total + count) % (size + need)])

        total += count
        size += need
    return delta


if __name__ == '__main__':
    a = source('A', 3)
    b = source('B', 10)
    c = source('C', 45)
    page = 0
    items = mix(page, (a, 2), (b, 3), (c, 5))
    while items:
        print('Page: %d\t%s' % (page, ' '.join(items)))
        page += 1
        items = mix(page, (a, 2), (b, 3), (c, 5))
&lt;/code&gt;&lt;/pre&gt;</content><category term="misc"></category></entry><entry><title>手机QQ2009聊天记录分析及提取</title><link href="https://whiler.github.io/QQ2009.sis.html" rel="alternate"></link><published>2009-10-14T00:00:00+08:00</published><updated>2009-10-14T00:00:00+08:00</updated><author><name></name></author><id>tag:whiler.github.io,2009-10-14:/QQ2009.sis.html</id><summary type="html">&lt;p&gt;symbian series 60 3&lt;sup&gt;rd&lt;/sup&gt; qq mobile chat log parse and extract.&lt;/p&gt;</summary><content type="html">&lt;p&gt;这是我的最早一个像程序的程序。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;十月十三号用上手机QQ2009了，一看，果然更花哨了。但以前写的手机QQ聊天记录提取程序用不上了，莫办法，重新分析。&lt;/p&gt;
&lt;p&gt;一手机QQ2009聊天记录文件的存放位置&lt;/p&gt;
&lt;p&gt;C:/System/data/Tencent/QQ/自己的QQ号码/好友的QQ号码/msg.info&lt;/p&gt;
&lt;p&gt;假如手机QQ装在E盘的把，上面盘符改成E就是了。&lt;/p&gt;
&lt;p&gt;二手机QQ2009聊天记录文件的字符编码&lt;/p&gt;
&lt;p&gt;手机QQ2009聊天记录文件的字符编码还是和手机QQ2008聊天记录文件的字符编码一样的，用的是UTF-16&lt;/p&gt;
&lt;p&gt;三手机QQ2009聊天记录文件结构分析&lt;/p&gt;
&lt;p&gt;和手机QQ2008聊天记录文件不一样了！&lt;/p&gt;
&lt;p&gt;注：我用的是十六进制分析&lt;/p&gt;
&lt;p&gt;消息分位发送消息和接收消息&lt;/p&gt;
&lt;p&gt;发送消息&lt;/p&gt;
&lt;p&gt;发送消息的十六进制表示以a8 ??(??表示一个十六进制数)标记开始并以它标记结束，接着用四个字节记录这条消息的序列，接着空出六个字节来，下一个字节是十六进制的80，说明消息是发送消息，从此以后位消息内容，直到，消息结束标记a8 ??。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;发送消息 “不”字的消息的十六进制&lt;/p&gt;
&lt;p&gt;a8 024a d5 0a d3 00 00 00 00 00 00800d 4ea8 02&lt;/p&gt;
&lt;p&gt;注： a8 02 中的 02 是随机的，但前后统一。&lt;/p&gt;
&lt;p&gt;接收消息&lt;/p&gt;
&lt;p&gt;发送消息的十六进制表示以a8 ??标记开始并以它标记结束，接着用四个字节记录这条消息的序列，接着空出六个字节来，下一个字节是十六进制的00，说明消息是发送消息，从此以后位消息内容，直到，消息结束标记a8 ??。&lt;/p&gt;
&lt;p&gt;接收消息 “不”字的消息的十六进制&lt;/p&gt;
&lt;p&gt;a8 064a d5 0a bf 00 00 00 00 00 00000d 4ea8 06&lt;/p&gt;
&lt;p&gt;注： a8 06 中的 06 是随机的，但前后统一。&lt;/p&gt;
&lt;p&gt;四 提取手机QQ2009的聊天记录&lt;/p&gt;
&lt;p&gt;经过分析，提取就简单了。&lt;/p&gt;
&lt;p&gt;需要提取手机QQ2009聊天记录的友友可以把你的msg.info文件发给俺：&lt;/p&gt;
&lt;p&gt;最后，这是为了师太写的，嘿嘿。&lt;/p&gt;
&lt;p&gt;分析有误的地方请指出，一起分享；代码写得差了，请多指教。&lt;/p&gt;
&lt;p&gt;补：上网一看，汗，要把手机QQ2008以前聊天记录的导入到手机QQ2009里面来还没人做，俺继续研究，应该不难，手机QQ2008的聊天记录俺有分析及提取的程序，嘿嘿。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面是提取手机QQ2009聊天记录的Python语言代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# Encoding:UTF-8
# FileName:PickupMobileQQ2009Message
# Date:2009_10_14

# from DMQCR.convert import OtoA
# I write this module for convert the expression code to char code

def pickup(path):
    fp = file(path)
    wfp = file(path.replace(&amp;quot;info&amp;quot;, &amp;quot;txt&amp;quot;), &amp;quot;a&amp;quot;)
    while True :
        mark = fp.read(2)  # one message's start and end mark
        if not mark:
            break
        fp.read(10)  # the ten chars are useless for pickup.
        flag = fp.read(1)  # send flag 80 end,00 receive
        message = &amp;quot;&amp;quot;
        while True:
            t = fp.read(2)
            if mark != t:
                message += t
            else:
                message = message.replace(&amp;quot;\x20\x00&amp;quot;, &amp;quot;&amp;quot;)
                message = message.decode(&amp;quot;UTF-16&amp;quot;)  # if you have some function to convert the expression code to char code,plaese change this line &amp;quot;message=functionname(massage).decode(&amp;quot;UTF-16&amp;quot;)&amp;quot;
            if &amp;quot;\x80&amp;quot; == flag:
                wfp.write(&amp;quot;SEND:&amp;quot; + message.encode(&amp;quot;UTF-8&amp;quot;) + &amp;quot;\r\n&amp;quot;)
                print &amp;quot;SEND: &amp;quot;, message
            else:
                wfp.write(&amp;quot;RECEIVE: &amp;quot; + message.encode(&amp;quot;UTF-8&amp;quot;) + &amp;quot;\r\n&amp;quot;)
                print &amp;quot;RECEIVE:&amp;quot;, message
            pass  # you can do more
            del message
            break
    fp.close()
    wfp.close()
    del mark, flag, wfp, fp

if __name__ == &amp;quot;__main__&amp;quot;:
    print &amp;quot;Running--------&amp;quot;
    pickup(&amp;quot;e:\\msg.info&amp;quot;)
    print &amp;quot;:-&amp;quot; * 20
&lt;/code&gt;&lt;/pre&gt;</content><category term="misc"></category></entry></feed>