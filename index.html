<!DOCTYPE html><html lang=zh class=borderbox><head><meta charset=utf-8><meta name=viewport content="width=device-width, initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><title>轨迹</title><link rel=icon href=https://whiler.github.io/favicon.svg><link rel=stylesheet href=https://whiler.github.io/theme/css/styles.min.5af50aa8.css><script defer id=entry src=https://whiler.github.io/theme/scripts/bootstrap.min.7ba17c5d.js data-disqus=traced data-config={}></script><link href=https://whiler.github.io/feed.xml type=application/atom+xml rel=alternate title="轨迹 Atom Feed"></head><body><header><h1><a href=https://whiler.github.io>轨迹</a></h1></header><hr><article class="typo main"><section><header><h2><a href=https://whiler.github.io/noscreen.html>NoScreen 简介</a></h2></header><hr><div class=meta><span>发布于<a href=https://whiler.github.io/archives.html title=归档><time datetime=2023-03-07T00:00:00+08:00>2023年03月07日</time></a></span></div><article><p>先上成品 <a href=https://noscr.v6.navy>https://noscr.v6.navy</a> 。</p><h2>咋来的？</h2><p>替表姐远程维护电脑的时候，被各种远程桌面应用折腾得不行不行的，索性自己搓一个。这就有了 <strong>NoScreen</strong> ，一个打开浏览器就能控制远程电脑的应用。</p><h2>啥是远程桌面应用？</h2><p>所谓的远程桌面应用，就是字面意思： <span class=arithmatex><span class=MathJax_Preview>远程桌面 = 控制 + 远程 + 电脑桌面</span><script type=math/tex>远程桌面 = 控制 + 远程 + 电脑桌面</script></span> 。</p><p>按下开关，灯就亮了，这是控制；按下遥控器的「静音」按钮，电视机就没声了，是遥控，是远程控制；点击自己的鼠标，远方电脑屏幕上的窗口就关闭了，这是远程控制电脑。</p><p>被控制的东西从灯、电视机到电脑，控制器从开关、遥控器到鼠标和键盘，控制距离从一间屋子到一个城市，这一切都没有本质的区别，都是操作控制器传递命令，让被控物体执行命并给出反馈。</p><pre><code class=language-sequence>人-&gt;遥控器: 按下静音按钮
遥控器-&gt;电视机: 静音
电视机--&gt;人: 没声了
</code></pre><h2>怎么搓？</h2><p>远程桌面的控制器是鼠标和键盘，命令是键盘按键、鼠标位置和鼠标点击，反馈显示在远程电脑屏幕上，可以通过截图把反馈传回去。</p><p>搞一个程序，监听键盘按键、鼠标移动和点击事件，这种基本操作就搞定了控制器。把监听到的命令编码后通过网络传递到另一台电脑的程序，调用多种自动化控制软件执行这些命令，这就搞定了执行命令。致于反馈，搞一个程序定时截图，通过网络把截图传给另一个程序并显示，就搞定了。</p><pre><code class=language-sequence>participant 人
participant 控制器
participant 执行程序
participant 屏幕

Note over 控制器,执行程序: 网络

人-&gt;控制器: 按下空格键
控制器-&gt;执行程序: 按下空格键
执行程序 --&gt; 执行程序: 截图
执行程序-&gt;控制器: 显示截图
控制器--&gt;人: 按下空格键成功了
</code></pre><p>「控制」和「执行」实现起来都没什么大问题，「反馈」实现起来问题很大，主要有：家庭宽带的上传很低，图像传输需要占用大量带宽；截图接口耗时较高，每秒截图 20 次都难。</p><p>把一张截图看作视频的一帧，那么把连续多张截图编码成视频就可以节省大量带宽。</p><p>按照「被控程序」把截图编码成视频，「控制程序」远程实时播放视频这个思路，我在流媒体传输和播放上走了不少弯路…… RTMP、RTSP、HLS 和 ffmpeg 几乎让我放弃把截图编码成视频这条路。</p><p>偶然看到 WebRTC 的 getDisplayMedia 接口，它简直就是为远程桌面量身定制的！不用操心视频编码和传输了，也不用担心截图耗时，一步到位。WebRTC 的 RTCPeerConnection 还解决了网络连接的问题，直连或者中转都能搞定。还不用考虑多操作系统多架构兼容的问题，浏览器都搞定了，真香！就它了。</p><p>选定 WebRTC 后，就需要重新实现控制器和执行程序了。在网页中捕获键盘按键、鼠标移动和点击非常方便，控制器的原型很快就搞定了。被控端的执行程序有两种实现方式：要么作为客户端从服务器上拉取命令，然后执行；要么作为服务端，等控制端把命令推过来，再执行。单独为传递命令搞一个服务太麻烦，延长了数据链，还提高了安全风险，不行只能做服务端。控制端通过 RTCPeerConnection 直接把命令传给被控端，被控端将命令转发给本地执行程序，没有第三方服务的介入，靠谱，我看行。做服务端也带来了一个问题：因为只能在 HTTPS 环境下才能调用 getDisplayMedia 接口，执行程序必须提供 HTTPS 环境。搞一个服务器，定期更新 HTTPS 证书，把执行程序和证书一起打包，提供下载链接，证书过期了就重新下载。而且 WebRTC 本来就需要一个服务器托管网页和信令服务，可以把更新证书和打包的活也交给它。</p><p>就这么愉快地把所有的问题都搞定了，所有涉及到的程序和服务都开源了 <a href=https://github.com/whiler/noscreen>https://github.com/whiler/noscreen</a> 。</p><h2>怎么用？</h2><p>如果是使用远程桌面这个功能。</p><p>被控端打开 <a href=https://noscr.v6.navy/ >https://noscr.v6.navy/</a> ，选择对应的被控端程序包下载，解压并执行，然后点击页面上的「共享」按钮，最后告诉控制端你的编号就可以了。</p><p>控制端打开 <a href=https://noscr.v6.navy/ >https://noscr.v6.navy/</a> ，输入被控端的编号，点击「控制」即可。</p><p><img alt=效果图 src="https://search.pstatic.net/common?src=https://i.imgur.com/tlR6bX2.png" title=效果图></p><p>如果你想自己部署这样的远程控制系统，可以参考 <a href=https://github.com/whiler/noscreen/blob/master/deploy.md>deploy.md</a> ，里面有为 Ubuntu 和 Debian 实现的一键部署脚本。</p></article></section><hr><section><h3>更多文章</h3><ol><li><a href=https://whiler.github.io/paper-circle.html title=不用任何粘接工具，把一张纸撕成一个纸圈>把一张纸撕成一个纸圈</a><span>发布于<a href=https://whiler.github.io/archives.html title=归档><time datetime=2018-05-21T00:00:00+08:00>2018年05月21日</time></a></span></li><li><a href=https://whiler.github.io/puzzle.html title="用 HTML/JavaScript/CSS 写了一个简单的拼图游戏。">写了一个简单的拼图游戏</a><span>更新于<a href=https://whiler.github.io/archives.html title=归档><time datetime=2018-05-05T00:00:00+08:00>2018年05月05日</time></a></span></li><li><a href=https://whiler.github.io/bypass-via-vpn.html title="利用 域名列表 、dnsmasq 、 iptables 和 ipset 配合 虚拟私用网络 精确到域名解决网络封锁。">用虚拟私用网络访问敏感网络</a><span>发布于<a href=https://whiler.github.io/archives.html title=归档><time datetime=2016-10-18T00:00:00+08:00>2016年10月18日</time></a></span></li><li><a href=https://whiler.github.io/heart.html title=半夜没事瞎折腾，想到绘制心形图案消磨时间。>绘制心形图案</a><span>发布于<a href=https://whiler.github.io/archives.html title=归档><time datetime=2016-04-14T00:00:00+08:00>2016年04月14日</time></a></span></li><li><a href=https://whiler.github.io/bypass.html title="用域名列表、dnsmasq 、 pdnsd 、 iptables 和 ipset 配合 shadowsocks-libev 精确到域名解决 tcp 连接封锁、dns 劫持、dns 请求 udp 丢包的问题，绕过网络封锁。">绕开网络封锁访问敏感域名</a><span>发布于<a href=https://whiler.github.io/archives.html title=归档><time datetime=2016-04-11T00:00:00+08:00>2016年04月11日</time></a></span></li><li><a href=https://whiler.github.io/blog.html title=闷头写代码到深夜，灵感闪现，迅速解决困扰了很久的问题，想要欢呼一下，发现已经是深夜了，作罢。>关于这个博客</a><span>更新于<a href=https://whiler.github.io/archives.html title=归档><time datetime=2023-03-08T00:00:00+08:00>2023年03月08日</time></a></span></li></ol></section><nav><span>上一页</span> 1 / 2 <a href=https://whiler.github.io/page/2/ >下一页</a></nav></article><hr><footer>始于 2016</footer></body></html>