<!DOCTYPE html><html lang=cmn manifest=https://whiler.github.io/index.html.appcache><head><meta charset=utf-8><meta name=viewport content="width=device-width, initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><title>轨迹/trace</title><link rel=stylesheet href=https://whiler.github.io/theme/css/styles.min.24c1f063.css><link rel=icon href=https://whiler.github.io/favicon.svg><link href=https://whiler.github.io/feed.xml type=application/atom+xml rel=alternate title="轨迹/trace Atom Feed"><script async id=entry src=https://whiler.github.io/theme/scripts/bootstrap.min.a5e60ff0.js data-ga=UA-74531835-1 data-disqus=traced data-config={}></script></head><body><header><h1><a href=https://whiler.github.io title="I leave no trace of wings in the air, but I am glad I have had my flight.">轨迹/trace</a></h1></header><hr><article><aside class=main><h2 class=center><a href=https://whiler.github.io/puzzle.html>写了一个简单的拼图游戏</a></h2><hr><div class=meta><span>发布于/Published: <a href=https://whiler.github.io/archives.html title=归档/Archives><time datetime=2018-04-14T00:00:00+08:00>Sat 14 April 2018</time></a></span><span>更新于/Updated: <a href=https://whiler.github.io/archives.html title=归档/Archives><time datetime=2018-04-24T00:00:00+08:00>Tue 24 April 2018</time></a></span></div><div class=content><p>游戏地址： <a href=./html/puzzle/ >拼图/Puzzle</a></p><p>早就想写一个拼图游戏了，以前被 <code>生成的拼图没法还原</code> 的问题唬住了，迟迟没能动手写。 今天抽了几个小时做了一个简单的拼图游戏。</p><p>随机生成的拼图不一定能还原，但是可以通过 <strong>从还原好的拼图随机打乱</strong> 的方式生成拼图。 这样，生成的拼图 100% 能还原，解决了 <code>生成的拼图没法还原</code> 的问题。</p><p>在 <strong>从还原好的拼图随机打乱</strong> 时遇到一个棘手的问题，白块总是「原地踏步」——白块平均概率向四个方向移动，走了一圈又回到了原位。 找到一个不是很完美的解决办法，通过白块当前的位置动态计算向四个方向移动的概率，然后按照四个方向不同的概率移动，终于走出起始点了。 但是，当白块移动到正中央的时候四个方向的概率又相同了，又有「原地踏步」的可能。 目前没有想到其他更好的办法。</p><p>没有 <strong>自动还原</strong> 功能时，总想着把这个功能加上，费劲实现这个功能后就不再想亲自好好玩一把拼图了。</p><p><strong>自动还原</strong> 功能其实并不难，前期调研时候就知道可以用 <em>A 星</em> 算法实现，难在学习和实现这个算法上了，还有 <em>A 星</em> 依赖的 <em>二叉堆</em> 。</p><p><em>A 星</em> 算法是一个启发性寻路算法，是最有效的直接搜索算法。其他的寻路算法还有广度优先、深度优先和 DijKstra 算法。 算法不断从开放区域选取代价最小的节点，通过该节点再生成该节点的子节点并放到开放区域中，直到找到目标节点。 算法的关键在 <strong>选取代价最小的节点</strong> ，这个操作需要预估该节点到目标节点的代价。</p><p><a href=https://gist.github.com/whiler/259285dca698f7b59970c3d34584111c><img alt=AStar src=https://whiler.github.io/assets/astar.svg></a></p><p><em>A 星</em> 算法每次都需要选取代价最小的节点，这样的操作十分适合用 <em>二叉堆</em> 来实现。 <em>二叉堆</em> 是一种队列，不同于常见的先进先出、先进后出队列，它随意进队，最小的出队。进队出队的时间复杂队都是 <span><span class=MathJax_Preview>O(log(n))</span><script type=math/tex>O(log(n))</script></span> 。 它用线性的数组／列表抽象地构造出一个完全二叉树，树上每一个节点小于它的子节点。</p><p><a href=https://gist.github.com/whiler/67668f14c0466eca081a203d5655f779><img alt=BinaryHeap src=https://whiler.github.io/assets/binheap.svg></a></p><h3>变更历史</h3><h4>2018-04-24</h4><ul><li>完善用户体验<ul><li>新增「开始」交互界面</li><li>新增 「游戏中」交互界面</li><li>新增 「游戏结束」交互界面</li></ul></li><li>新增 <strong>「自动还原」</strong> 功能</li><li>可以随意选取开始位置</li><li>新增「猫」「狗」背景图，随机选择概率分别是 50% 和 30%</li></ul><h4>2018-04-14</h4><ul><li>增加还原判定</li><li>适配竖屏</li><li>参数支持<ul><li>网格设置</li><li>难度设置</li><li>背景图更换</li></ul></li></ul></div></aside><hr><aside class=others><h3>其他文章/Other articles</h3><ol class=list><li><a href=https://whiler.github.io/bypass-via-vpn.html title=用虚拟私用网络访问敏感网络>用虚拟私用网络访问敏感网络</a><div class=meta><span>发布于/Published: <a href=https://whiler.github.io/archives.html title=归档/Archives><time datetime=2016-10-18T00:00:00+08:00>Tue 18 October 2016</time></a></span></div></li><li><a href=https://whiler.github.io/heart.html title=绘制心形图案>绘制心形图案</a><div class=meta><span>发布于/Published: <a href=https://whiler.github.io/archives.html title=归档/Archives><time datetime=2016-04-14T00:00:00+08:00>Thu 14 April 2016</time></a></span></div></li><li><a href=https://whiler.github.io/bypass.html title=绕开网络封锁访问敏感域名>绕开网络封锁访问敏感域名</a><div class=meta><span>发布于/Published: <a href=https://whiler.github.io/archives.html title=归档/Archives><time datetime=2016-04-11T00:00:00+08:00>Mon 11 April 2016</time></a></span></div></li><li><a href=https://whiler.github.io/blog.html title=关于这个博客>关于这个博客</a><div class=meta><span>发布于/Published: <a href=https://whiler.github.io/archives.html title=归档/Archives><time datetime=2016-03-04T00:00:00+08:00>Fri 04 March 2016</time></a></span></div></li><li><a href=https://whiler.github.io/about.html title=关于/about>关于/about</a><div class=meta><span>发布于/Published: <a href=https://whiler.github.io/archives.html title=归档/Archives><time datetime=2016-02-28T00:00:00+08:00>Sun 28 February 2016</time></a></span></div></li><li><a href=https://whiler.github.io/gpg.html title="my gpg public key">my gpg public key</a><div class=meta><span>发布于/Published: <a href=https://whiler.github.io/archives.html title=归档/Archives><time datetime=2015-08-29T00:00:00+08:00>Sat 29 August 2015</time></a></span></div></li></ol><div class="paginator center"><a>上一页/Previous</a>1 / 2<a href=https://whiler.github.io/page/2/ >下一页/Next</a></div></aside></article><hr><footer class=center>始于 2016 | SINCE 2016</footer></body></html>