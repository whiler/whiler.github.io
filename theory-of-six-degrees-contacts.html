<!DOCTYPE html><html lang=zh class=borderbox><head><meta charset=utf-8><meta name=viewport content="width=device-width, initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=description content=一次求职笔试，考到了六度分隔理论，判断两个人之间是否存在可能的联系。><title>六度分割理论</title><link rel=icon href=https://whiler.github.io/favicon.svg><link rel=stylesheet href=https://whiler.github.io/theme/css/styles.min.5af50aa8.css><script defer id=entry src=https://whiler.github.io/theme/scripts/bootstrap.min.7ba17c5d.js data-disqus=traced data-config='{"uuid":"f8f01700-1a02-4151-ab5f-a33e215cec60"}'></script><link href=https://whiler.github.io/feed.xml type=application/atom+xml rel=alternate title="轨迹 Atom Feed"></head><body><header><h1><a href=https://whiler.github.io>轨迹</a></h1></header><hr><article class="typo main"><header><h2>六度分割理论</h2></header><hr><div class=meta><span>发布于<a href=https://whiler.github.io/archives.html title=归档><time datetime=2014-09-17T00:00:00+08:00>2014年09月17日</time></a></span></div><section><p>一次求职笔试，考到了六度分隔理论，判断两个人之间是否存在可能的联系。 问题是比较简单的，就是检查权重为1的无向图中两个节点在 6 层内是否有相通的路径。</p><h3>解决办法</h3><ol><li>收集每一个人的一度好友</li><li>从一个人开始，遍历他的所有好友，检查是否是另一个人的好友</li><li>递归检查好友的好友，同时排除上一个好友</li></ol><h3>实现</h3><pre><code class=language-python>#!/usr/bin/env python
# -*- coding: utf-8 -*-
#

import collections
import itertools
import logging
import random
import string

logging.basicConfig(level=logging.NOTSET,
                    format='[%(levelname)s]\t%(asctime)s\t%(message)s',
                    datefmt='%Y-%m-%d %H:%M:%S %Z')

DEPTH = 6


def create_edges(count):
    edges = set()
    for _ in range(count):
        a = random.choice(string.ascii_uppercase)
        b = random.choice(string.ascii_uppercase)
        while a == b or (a, b) in edges or (b, a) in edges:
            a = random.choice(string.ascii_uppercase)
            b = random.choice(string.ascii_uppercase)
        edges.add((a, b))
    return edges


def build_trees(edges):
    trees = collections.defaultdict(set)
    for a, b in edges:
        trees[a].add(b)
    return trees


def find(trees, a, b):
    if not (a in trees and b in trees):
        return -1
    elif a == b:
        return 0
    return walk(trees, a, b, 1) or -1


def walk(trees, a, b, depth, block=None):
    if depth &gt; DEPTH:
        return -1
    children = trees[a]
    if b in children:
        return depth
    else:
        for child in children:
            if child == block:
                continue
            dep = walk(trees, child, b, depth + 1, a)
            if dep is not None:
                return dep


if __name__ == '__main__':
    edges = create_edges(128)
    trees = build_trees(edges)
    for a, b in itertools.combinations(string.ascii_uppercase, 2):
        dep = find(trees, a, b)
        logging.debug('degrees between %s and %s is %d', a, b, dep)
</code></pre><p>关于六度分隔理论的详细介绍，可以参考 <a href=https://en.wikipedia.org/wiki/Six_degrees_of_separation>Six degrees of separation</a> 。</p></section></article><aside><h3>评论</h3><section id=disqus_thread></section><noscript>请启用 JavaScript 脚本以查看评论。</noscript></aside><hr><footer>始于 2016</footer></body></html>